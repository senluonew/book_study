面试官，你好，我叫罗森，11年毕业于安徽财经大学计算机系，双证齐全

第一家公司是南京迈特望技术股份有限公司，16年入职的，外派到杭州亚信，开始是在账务中心模块，主要做老crm业务梳理和重构，后面去了电子发票中心模块，做一些电子发票优化和电子专票需求。
第二家公司就是现在上班这个，备胎网络科技有限公司，隶属于浙江艾卡资产管理有限公司的下属公司。
      刚到这家公司时，主要做的是备胎好车（商家版）和备胎资产（员工端）这两款二手车交易平台APP，当时公司主要做的是二手车贷款，发展处于上升期，想要做成瓜子那种二手车交易平台，现有的
项目架构已经不能满足要求了，所以
项目这块做得很大的变动，将但服务拆分成多服务，采用的是dubbo+zk模式。我主要做的是消息模块，主要就是展示车商的信息和社交信息，如发车，关注他人，发布动态，
技术方面采用的是MongoDB+redis。重构完成之后主要做的就是版本升级，主要做了支付渠道升级，4s业务需求，消息推送模块化，等等这些。
     后来去了约财湾p2p项目，当时p2p第三方存管应政府要求，必须对接政府指定的存管公司，并且在要求时间上线，主要就是对接第三方存管api，
	以及开发app服务端代码。
   之后做的是保险项目，主要做的是基于用户，部门，角色 这三个点做菜单，按钮 权限管理，保险项目比较老，前后端不分离，单服务，就采用了shiro+ session+本地缓存，
    20年时上国家贷款限制以及二手车市场低迷，再加上p2p基本凉了，所以公司这块做了转型，一方面对外接项目，也再开发新的产品线。因为这些都是新的项目，所以架构这块都有我们自己来定，
技术栈就是JDK1.8+Springboot+Mybatis+mysql+Redis+工作流，做了几个项目之后每次都重新做，老项目复用性不高。在空闲时间，就搭了个模板项目，把一些能复用的功能写好，
比如用户管理，菜单管理，权限管理，引入了lombok和mybatisplus这些插件，精简代码量。因为是模板项目，所以前端h5页面这块只能我们做的，前端帮我们搭了个脚手架。后面的项目基本都是
以这个模板来做二次开发。
这边基本就是我的大概情况。

一mian
1.mysql於引结构？  
索引的定义：索引一种特殊的文件结构（InnoDB数据表上的的索引结构是表空间的一个组成部分），包含着对数据表里所有记录的引用指针。
索引的优点：加快检索速度（最主要）；使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
索引的缺点：时间-> 创建和维护索引需要消耗时间，相应降低表增删改效率；空间-> 索引需要占用物理空间
索引的分类：聚集索引（又叫主键索引或聚簇索引），
			定义：数据行的物理顺序与列值的逻辑顺序相同，一个表中只能拥有一个聚集索引。如果不创建，系统会自动创建一个隐含地列作为表的聚集索引
		  非聚集索引：定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引
		              细分：普通索引，唯一索引，全文索引
					  问题：二次查询问题（关联id地址，然后再到达数据地址）；解决方法：复合索引（覆盖索引），覆盖要查询的列（满足最左原则），这样性能会大幅提升
索引的结构：hash和二叉树，二叉树又有b树，和b+树（最常用）。				
			概念，InnDB存储引擎默认索引是：B+树索引。对于哈希来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；
		   其余大部分场景，建议选择BTree索引。

B树和B+树的区别：在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。
			     B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。
使用B树的好处：  B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。
				这种特性使得B树在特定数据重复多次查询的场景中更加高效。

使用B+树的好处：由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。
                B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，
				然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

Hash索引和B+树所有有什么区别或者说优劣呢?
	首先要知道Hash索引和B+树索引的底层实现原理：hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，
	之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，
	然后根据查询判断是否需要回表查询数据。
那么可以看出他们有以下的不同：
	hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。
       因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。
	   而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
	hash索引不支持使用索引进行排序，原理同上。
	hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
	hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
	hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。
		而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。

数据库为什么使用B+树而不是B树：
	B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
	B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。
		这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，
		一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
	B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。
		而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
	B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历
	。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
	增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。

B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，
	在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 
	在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。


2.redis持久化策路？      
策略：两种持久化机制 RDB（默认） 和 AOF 
RDB: 是redis database缩写快照，
	定义：是redis默认的持久化方式，按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件是dump.rdb。通过配置文件中save参数来定义快照的周期，
	优点：1：只有一个文件dump.rdb ,方便持久化    
		  2：容灾性好，一个文件可以保存到安全的磁盘  
		  3：性能最大化，fork 子进程来完成写操作，让主线程处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
		  4.相对于数据集大时，比 AOF 的启动效率更高。
	缺点：1：数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
		  2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。
AOF:
	优点：1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
		  2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
		  3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)
	缺点：1、AOF 文件比 RDB 文件大，且恢复速度慢。
		  2、数据集大的时候，比 rdb 启动效率低。
俩种持久化的优缺点是什么？
	AOF文件比RDB更新频率高，优先使用AOF还原数据。
	AOF比RDB更安全也更大
	RDB性能比AOF好
	如果两个都配了优先加载AOF
		  
如何选择合适的持久化方式

	一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，
	因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
	
	如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。
	
	有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，
	除此之外，使用RDB还可以避免AOF程序的bug。
	
	如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。


3.zookeeper节卢类型说一下；
Zookeeper 文件系统：
Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。
与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。
Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。
 
（1）PERSISTENT-持久节点
​	除非手动删除，否则节点一直存在于 Zookeeper 上
（2）EPHEMERAL-临时节点
​	临时节点的生命周期与客户端会话绑定，一旦客户端会话失效
	（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。
（3）PERSISTENT_SEQUENTIAL-持久顺序节点
​	基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
（4）EPHEMERAL_SEQUENTIAL-临时顺序节点
​	基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。


4.zookeeper选举机制
zk会进行多轮的投票，直到某一个节点的票数大于或等于半数以上，在3个节点中，总共会进行2轮的投票：

第一轮，每个节点启动时投票给自己，那这样zk1，zk2，zk3各有一票。
第二轮，每个节点投票给大于自己myid，那这样zk2启动时又获得一票。
	加上自己给自己投的那一票。总共有2票。2票大于了当前节点总数的半数，所以投票终止。zk2当选leader。
zk选举什么时候会被触发呢？一是启动时会被触发，二是leader宕机时会被触发。
上面的例子中，如果节点2宕机，根据规则，那获得leader的就应该是zk3了。

5.zookeeper主节点故障，如何重新选举
当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，
且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。
状态同步保证了 leader 和 server 具有相同的系统状态。

6.syn机制：
7.线程池的核心参数；
8.ThreadLocal的实现，原理，业务用来做什么？
使用： 
用户全局token  - 使用场景：前端请求带有用户token，全局获取用信息  原理实现：自定义拦截器，通过token获取用户信息，将用户信息放入ThreadL工程肯

MDC全局链路id（调用链） 使用 org.slf4j.MDC 来实现此功能，内部就是通过 ThreadLocal 来实现的，具体实现如下：
	当前端发送请求到服务 A时，服务 A会生成一个类似UUID的traceId字符串，
	将此字符串放入当前线程的ThreadLocal中，在调用服务 B的时候，将traceId写入到请求的Header中，服务 B在接收请求时会先判断请求的Header中是否有traceId，如果存在则写入自己线程的ThreadLocal中。


9.springDI 的原理；
定义：即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的
	各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。
实现方式：依赖注入是时下最流行的IOC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。
使用：两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。
	

10.四次挥手；
三次握手：
客户端–发送带有 SYN 标志的数据包–一次握手–服务端
服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端
目的：三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
四次挥手：
客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号
服务器-关闭与客户端的连接，发送一个 FIN 给客户端
客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1

11.gc root选举：
	引用计数算法 ：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的
	可达性分析算法 ：基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，
	根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 
	或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的
GC roots 对象种类
	固定节点: 1：虚拟机栈中引用的对象，2方法去中静态属性引用的对象 3 在方法区中常量引用的对象  4所有被同步锁（synchronized关键字）持有的对象。 等等
	非固定： 不同收集区


12.标记清除算法的过程，标记清除算法如何给对象分配内存空间？
过程：算法分为“标记”和“清除”两个阶段：首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。
分配：

13.cms算法的缺点：
主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：

明显缺点：
对 CPU 资源敏感；
无法处理浮动垃圾；
它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。


二mian
1.Corrunthashmap理解
2.ThreadLoca原理
3.hashmap:
4.Java数据类型，同步机制：
5.讲讲贪心算法；
贪心算法，又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，
选取当前状态下最好/最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。{看着这个名字，贪心，
贪婪这两字的内在含义最为关键。这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，
贪图眼前局部的利益最大化，有点走一步看一步的感觉。
贪婪法的基本步骤：

步骤1：从某个初始解出发；
步骤2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；
步骤3：将所有解综合起来。

6.如果线上用户出现502错误你怎么排查？
502是报错类型代码bad gateway错误的网关，502错误最通常的出现情况就是后端主机当机而在项目中，502错误的问题一般属于后台服务器挂掉的问题，例如：CPU使用过满、数据库连接数过大、内存不足、甚至是内存溢出等等因素诱发导致。

7.并发量很大，服务器宕机。你会怎么做？
熔断
比如营销服务挂了或者接口大量超时的异常情况，不能影响下单的主链路，涉及到积分的扣减一些操作可以在事后做补救。
限流
对突发如大促秒杀类的高并发，如果一些接口不做限流处理，可能直接就把服务打挂了，针对每个接口的压测性能的评估做出合适的限流尤为重要。
降级
熔断之后实际上可以说就是降级的一种，以熔断的举例来说营销接口熔断之后降级方案就是短时间内不再调用营销的服务，等到营销恢复之后再调用。
预案
一般来说，就算是有统一配置中心，在业务的高峰期也是不允许做出任何的变更的，但是通过配置合理的预案可以在紧急的时候做一些修改。

首先找出并发的瓶颈，并有针对的解决

服务：添加负载均衡层，将请求均匀打到系统层。
		系统层采用集群化部署多台机器，扛住初步的并发压力。
数据库：数据库分库分表 + 读写分离	
缓存集群引入：

考虑要素：不要盲目进行数据库扩容，数据库服务器成本昂贵，且本身就不是用来承载高并发的。
		 针对写少读多的请求，引入缓存集群，用缓存集群抗住大量的读请求。
		 引入消息中间件集群
	

三mian
1.syn和lock的区别，哪个更好？怎么选择？
2.hashmap源码，为什么8个节点变成红黑树又为什么到了6个节点才恢复为链表？
解释：当链表长度大于或等于阈值（默认为 8）的时候，如果同时还满足容量大于或等于 MIN_TREEIFY_CAPACITY（默认为 64）的要求，
就会把链表转换为红黑树。同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态

3.缓存穿透，怎么解决？
高并发下，由于一个key失效，而导致多个线程去mysql查同一业务数据并存到redis（并发下，存了多份数据），而一段时间后，多份数据同时失效。导致压力骤增
缓存穿透是指：缓存和数据库都没有的数据，被大量请求，比如订单号不可能为-1，但是用户请求了大量订单号为-1的数据，由于数据不存在，缓存就也不会存在该数据，
所有的请求都会直接穿透到数据库。
缓存雪崩是指：缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。

4:负载均衡算法，实现；
1、轮询法
将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载；
2、随机法
通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，
随着客户端调用服务端的次数增多， 其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果；
3、源地址哈希法
源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，
得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问；

4、加权轮询法
不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，
让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端；
5、加权随机法
与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序；

5.轮询和随机的缺点；
轮询：但是存在请求累积的问题
随机：分布不均

6.分布式服务治理；
7.dns送代和递归的区别；
8.算法题：最长回文串

9.为什么连接的时候是三次握手，关闭的时候却是四次握手？
三次握手是因为因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET（因为可能还有消息没处理完），所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。


四mian
1.自我介绍就背景进行一些提问
2.简单说说计算机网络
3.筍单描述一下从浏览器输入一个地址到汲务購整个交互过程

DNS 解析
TCP 连接
发送 HTTP 请求
服务器处理请求并返回 HTTP 报文
浏览器解析渲染页面
连接结束

4.说说数据结构
5.操作系统用过吗
6.用过linux的那些命令
1、cd命令  2、ls命令 3、grep命令  5、cp命令 6、mv命令 7、rm命令 9、kill命令 10 压缩解压  11 cat命令  12 权限命令 13、编辑，vi vim命令

7.查看一个进程监听了哪些端口
1、先查看进程pid
ps -ef | grep 进程名

2、通过pid查看占用端口
netstat -nap | grep 进程pid

端口查看进程：netstat -nap | grep 端口号


8.详细介绍项目（重点)

9.讲解之前工作经历中做的东西
10.做一道算法题（判断二叉树是否对称）
递归，
实现：
构建递归函数：
定义函数功能：判断左右两个结点是否对称相等
递归终止条件:没有子节点，说明当前结点是叶子结点
没有右子节点（因为是按从左到右的顺序比较的）左右结点不对称
public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        if(pRoot==null){
            return true;
        }
        return isSame(pRoot.left,pRoot.right);
    }
    private boolean isSame(TreeNode root1,TreeNode root2){
        if(root1==null){
            return root2==null;
        }
        if(root2==null){
            return root1==null;
        }
        if(root1.val!=root2.val){
            return false;
        }
        return isSame(root1.left,root2.right)&&isSame(root1.right,root2.left);
         
    }
}


10.java如何从源代码转换成机器码执行的


11.java缓存的击穿
12.网络的七层结构
13.tcpludp详解区别
14.https协议的交互过程
15.linux基础命令
16.linux开机过程
17.了解现在市面上主流的cpu架构
18.fpga概念了解吗
19.市面上的图数据库
20.raf讲解
21.图数据库底层存储
22.b树，b+树的概念和区别
23.红黑树平衡二叉树优缺点和应用场景
24.有没有了解docker等云技术

项目经验

备胎好车二手车交易平台项目
p2p项目
保险项目
瓜子二手车风控平台
外接项目：
湖南体育协会项目：
保安考试项目：
医疗机构设备管理系统：
亚米项目：公众号：亚米官方  小程序：亚米官方商城


Bean 的生命周期了解么?
下面的内容整理自：https://yemengying.com/2016/07/14/spring-bean-life-cycle/ ，除了这篇文章，再推荐一篇很不错的文章 ：https://www.cnblogs.com/zrtqsk/p/3735273.html 。

Bean 容器找到配置文件中 Spring Bean 的定义。
Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。
如果涉及到一些属性值 利用 set()方法设置一些属性值。
如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。
如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。
如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。
与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。
如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法
如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。
如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。
如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法
当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。
当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。

dubbo
（1）服务器注册与发现的流程
角色：
Provider：暴露服务的服务提供方
Consumer：调用远程服务消费方
Registry：服务注册与发现注册中心
Monitor：监控中心和访问调用统计
Container：服务运行容器

服务容器Container负责启动，加载，运行服务提供者。
服务提供者Provider在启动时，向注册中心注册自己提供的服务。
服务消费者Consumer在启动时，向注册中心订阅自己所需的服务。
注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。

（2）服务调用的流程
1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；
2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；
3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；
4、服务端存根（server stub）收到消息后进行解码（反序列化操作）；
5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；
6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；
7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；
8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；
9、服务消费方得到最终结果；
	  
归纳：调用某个接口的方法会调用之前生成的代理类，然后会从 cluster 中经过路由的过滤、负载均衡机制选择一个 invoker 发起远程调用，此时会记录此请求和请求的 ID 等待服务端的响应。
服务端接受请求之后会通过参数找到之前暴露存储的 map，得到相应的 exporter ，然后最终调用真正的实现类，再组装好结果返回，这个响应会带上之前请求的 ID。
消费者收到这个响应之后会通过 ID 去找之前记录的请求，然后找到请求之后将响应塞到对应的 Future 中，唤醒等待的线程，最后消费者得到响应，一个流程完毕。
关键的就是 cluster、路由、负载均衡，然后 Dubbo 默认是异步的，所以请求和响应是如何对应上的。

（3）RPC使用了哪些关键技术	  
1、动态代理
生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。

2、序列化和反序列化
在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。
序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。
目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。
反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。
目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。

3、NIO通信
出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。
可以选择Netty或者MINA来解决NIO数据传输的问题。

4、服务注册中心
可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。


mybatis
（1）mybatis查询数据库步骤
准备运行环境Environment，即创建数据源和事务工厂
创建核心配置对象Configuration，此对象包含mybatis的配置信息（xml或者注解方式配置）
创建SqlSessionFactory，用于创建数据库会话SqlSession
创建SqlSession进行数据库操作


mysql
（1）SQL语句在MySQL中的执行过程
查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit状态)
名词解释：
连接器： 身份认证和权限相关(登录 MySQL 的时候)。
查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
优化器： 按照 MySQL 认为最优的方案去执行。
简单来说 MySQL 主要分为 Server 层和存储引擎层：

Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，
			还有一个通用的日志模块 binlog 日志模块。
存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。
			现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。