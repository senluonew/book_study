一mian
1.mysql於引结构？  
索引的定义：索引一种特殊的文件结构（InnoDB数据表上的的索引结构是表空间的一个组成部分），包含着对数据表里所有记录的引用指针。
索引的优点：加快检索速度（最主要）；使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
索引的缺点：时间-> 创建和维护索引需要消耗时间，相应降低表增删改效率；空间-> 索引需要占用物理空间
索引的分类：聚集索引（又叫主键索引或聚簇索引），
			定义：数据行的物理顺序与列值的逻辑顺序相同，一个表中只能拥有一个聚集索引。如果不创建，系统会自动创建一个隐含地列作为表的聚集索引
		  非聚集索引：定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引
		              细分：普通索引，唯一索引，全文索引
					  问题：二次查询问题（关联id地址，然后再到达数据地址）；解决方法：复合索引（覆盖索引），覆盖要查询的列（满足最左原则），这样性能会大幅提升
索引的结构：hash和二叉树，二叉树又有b树，和b+树（最常用）。				
			概念，InnDB存储引擎默认索引是：B+树索引。对于哈希来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；
		   其余大部分场景，建议选择BTree索引。

B树和B+树的区别：在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。
			     B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。
使用B树的好处：  B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。
				这种特性使得B树在特定数据重复多次查询的场景中更加高效。

使用B+树的好处：由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。
                B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，
				然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

Hash索引和B+树所有有什么区别或者说优劣呢?
	首先要知道Hash索引和B+树索引的底层实现原理：hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，
	之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，
	然后根据查询判断是否需要回表查询数据。
那么可以看出他们有以下的不同：
	hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。
       因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。
	   而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
	hash索引不支持使用索引进行排序，原理同上。
	hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
	hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
	hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。
		而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。

数据库为什么使用B+树而不是B树：
	B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
	B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。
		这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，
		一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
	B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。
		而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
	B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历
	。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
	增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。

B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，
	在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 
	在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。


2.redis持久化策路？      
策略：两种持久化机制 RDB（默认） 和 AOF 
RDB: 是redis database缩写快照，
	定义：是redis默认的持久化方式，按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件是dump.rdb。通过配置文件中save参数来定义快照的周期，
	优点：1：只有一个文件dump.rdb ,方便持久化    
		  2：容灾性好，一个文件可以保存到安全的磁盘  
		  3：性能最大化，fork 子进程来完成写操作，让主线程处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
		  4.相对于数据集大时，比 AOF 的启动效率更高。
	缺点：1：数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
		  2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。
AOF:
	优点：1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
		  2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
		  3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)
	缺点：1、AOF 文件比 RDB 文件大，且恢复速度慢。
		  2、数据集大的时候，比 rdb 启动效率低。
俩种持久化的优缺点是什么？
	AOF文件比RDB更新频率高，优先使用AOF还原数据。
	AOF比RDB更安全也更大
	RDB性能比AOF好
	如果两个都配了优先加载AOF
		  
如何选择合适的持久化方式

	一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，
	因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
	
	如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。
	
	有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，
	除此之外，使用RDB还可以避免AOF程序的bug。
	
	如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。


3.zookeeper节卢类型说一下； 
	
4.zookeeper选举机制

5.zookeeper主节点故障，如何重新选举

6.syn机制：
7.线程池的核心参数；
8.ThreadLocal的实现，原理，业务用来做什么？
9.springD1的原理；
10.四次挥手；
11.gcroot选撑;
12.标记清除算法的过程，标记清楚算法如
何给对象分配内存空间？
13.cms算法的缺点；
二mian
1.Corrunthashmap理解
ThreadLoca原理
3.hashmap:
4.Java数据类型，同步机制：
5.讲讲贪心算法；
6.如果线上用户出现502错误你怎么排查？
7.并发量很大，服务器宕机。你会怎么
做？
三mian
1.syn和lock的区别，哪个更好？怎么选
择？
2.hashmap源码，为什么8个节点变成红無
树又为什么到了6个节点才恢复为链表？
3.缓存穿透，怎么解决？
负载均衡算法，实现；
5.轮询和随机的缺点；
6.分布式服务治理；
7.dns送代和递归的区别；
8.算法题：最长回文串
9.为什么连接的时候是三次握手，关闭的
时候却是四次握手？
四mian
1.自我介绍就背景进行一些提问
2.简单说说计算机网络
3.筍单描述一下从浏览器输入一个地址到
汲务購整个交互过程
4.说说数据结构
5.操作系统用过吗
6.用过linux的嘟些命令
7.查看一个进程监听了哪些端口
8.详细介绍项目（简历上的域名访问不
了)
9.讲解之前工作经历中做的东西10.做一道
算法题（判断二叉树是否对称）
10.java如何从源代码转换成机器码执行的
11.java的击穿
12.网络的七层结构
13.tcpludp详解区别
14.https协议的交互过程
15.linux基础命令
16.linux开机过程
17.了解现在市mian上主流的cpu架构
18.fpga概念了解吗
19.市mian上的图数据库
20.raf讲解
21.图数据库底层存储
22.b树，b+树的概念和区别
23.红黑树平衡二叉树优缺点和应用场景
24.有没有了解docker等云技术
